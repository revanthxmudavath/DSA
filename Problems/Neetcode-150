1. 347. Top K Frequent Elements - medium

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2

Output: [1,2]

Approach 1: Bucket Sort

public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        List<Integer>[] freq = new ArrayList[nums.length + 1];

        for(int i = 0; i<freq.length; i++){
            freq[i] = new ArrayList<>();
        }
        
        for(int i : nums) map.put(i, map.getOrDefault(i, 0)+1);

        // Bucket Sort: Assign frequencies to keys first (using map)
        // take an array, then make frequencies the key and append the values (nums[i]).
        // to each frequency
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){   
            freq[entry.getValue()].add(entry.getKey());                                         
        }

        int [] res = new int[k];
        int index = 0;
        // start from end, take values until k is satisfied
        for(int i = freq.length - 1; i>0 && index < k;i--){
            for(int x : freq[i]){
                res[index++] = x;
                if(index > k) return res;
            }
        }
        return res;
    }

Approach 2: Heap (Max Heap)

  public int[] topKFrequent(int[] nums, int k) {
     Map<Integer, Integer> map = new HashMap<>();
  
     for(int i : nums){
      map.put(i, map.getOrDefault(i, 0)+1);
     }
  
     PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);
  
     for(Map.Entry<Integer, Integer> entry: map.entrySet()){
      pq.offer(new int [] {entry.getValue(), entry.getKey()});
      if(pq.size() > k){
          pq.poll();
      }
     }
  
     int [] res = new int[k];
     for(int i=0;i<k;i++){
      res[i] = pq.poll()[1];
     }
     return res; 
}


2. 271. Encode and Decode Strings - medium

Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement encode and decode

Example 1:

Input: ["neet","code","love","you"]

Output:["neet","code","love","you"]

Approach: First store the length, separator and string - Encode
          initialize i, j. Parse until you find the separator, save the length and assign the string via (substring) to the list.

 public String encode(List<String> strs) {
        if( strs.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for(String i : strs){
            sb.append(i.length()).append('#').append(i);
        }

        return sb.toString();
    }

    public List<String> decode(String str) {
        if(str.length() == 0) return new ArrayList<>();

        List<String> arr = new ArrayList<>();

        int i = 0;
        int j = 0;

        while(i < str.length()){
            j = i + 1;

            while( str.charAt(j) != '#'){
                j++;
            }

            int length = Integer.parseInt(str.substring(i, j));
            i = j + 1;
            j = i + length;
            arr.add(str.substring(i, j));
            i = j;
        }
        return arr;

3. 238. Product of Array Except Self - Medium

Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].

Each product is guaranteed to fit in a 32-bit integer.

Example 1:

Input: nums = [1,2,4,6]

Output: [48,24,12,8]

Approach : Prefix - Suffix Product

Calculate prefix product in res [] array, initialize a varibale, start from last, multiply the indices of res with nums[i]

public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
       
        int [] res = new int[n];

        res[0] = 1;
        for(int i = 1; i<n;i++){
            res[i] = nums[i-1] * res[i-1];
        }
        int suff = 1;
        for(int i = n - 1; i>=0;i--){
            res[i] *= suff;
            suff *= nums[i];
        }
        return res;
    }
